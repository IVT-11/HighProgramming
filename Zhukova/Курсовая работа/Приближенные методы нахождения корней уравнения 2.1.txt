#include<stdio.h>
#include<math.h>
#include<stdlib.h>
#include<time.h>
double PROIZVOD(double,int, double,double);
//функция для нахождения производной, принимает значения переменных х, с и переменной vib,отвечающий за выбранное пользователем уравнение
double PROIZVOD(double xn, int vib, double c, double d)
{
	if(vib==1) return cos(c*xn);//если переменная vib равна 1, то функция возвращает производную уравнения 1 от переменной xn
	else if(vib==2) return exp(c*xn);//если переменная vib равна 2, то функция возвращает производную уравнения 2 от переменной xn
	else if(vib==3) return (5*pow(xn,4))+(c*2*xn);//если переменная vib равна 3, то функция возвращает производную уравнения 3 от переменной xn
	else if(vib==4) return c*pow(xn, c-1)-(c+1)*pow(xn,c);//если переменная vib равна 4, то функция возвращает производную уравнения 4 от переменной xn
	else if(vib==5) return 2*xn-c*pow(xn,c-1);//если переменная vib равна 5, то функция возвращает производную уравнения 5 от переменной xn
	else if(vib==6) return ((c*3*pow(xn,3))*(xn+d)-(c*pow(xn,3)-d))/pow(xn+d,2);//если переменная vib равна 6, то функция возвращает производную уравнения 6 от переменной xn
}
double FUNC(double,int,double,double);
//функция для нахождения функции, принимает значения переменных х, с, d и переменной vib,отвечающий за выбранное пользователем уравнение
double FUNC(double xn, int vib, double c, double d)
{
	if(vib==1) return sin(c*xn)-d;//если переменная vib равна 1, то функция возвращает значение функции от уравнения 1 от переменной xn
	else if(vib==2) return exp(c*xn)-d;//если переменная vib равна 2, то функция возвращает значение функции от уравнения 2 от переменной xn
	else if(vib==3) return pow(xn,5)+(c*xn*xn)-d;//если переменная vib равна 3, то функция возвращает значение функции от уравнения 3 от переменной xn
	else if(vib==4) return pow(xn, c)-pow(xn,c+1)+d;//если переменная vib равна 4, то функция возвращает значение функции от уравнения 4 от переменной xn
	else if(vib==5) return (pow(xn,2)-d)-(pow(xn,c)-6);//если переменная vib равна 5, то функция возвращает значение функции от уравнения 5 от переменной xn
	else if(vib==6) return (c*pow(xn,3)-d)/(xn+d);//если переменная vib равна 6, то функция возвращает значение функции от уравнения 6 от переменной 
}
double KASAT(double, double , double , double, double *, int);
//функция для вычисления приближенного значения с помощью метода касательных, принимает начальный х, переменные c, d, toch(отвечающую за точность)
//а так же указатель на переменную step(это понадобиться, чтобы в мейне вывести точность как количество знаков после запятой)
//и переменную vib, отвечающую за номер выбранного пользователем уравнения
double KASAT(double xn1, double c, double d, double toch, double *step, int vib)
{

int iter=0;//переменная iter отвечает за количество итераций цикла и изначально равна нулю
double  xn2=xn1, func, proiz;//переменная xn2 отвечает за следующий x, найденный в ходе программы(изначально равен x введенному с клавиатуры), а переменные func и proiz соответственно для вычисления функции и производной
  do//начало цикла
  {
  	    xn1=xn2;//"предыдущему" x присваиваем "следующий" х 
  		func=FUNC(xn1,vib,c,d);//находим функцию от х с помощи функции FUNC
        proiz=PROIZVOD(xn1,vib,c,d);//находим производную от х с помощью функции PROIZVOD
        xn2=xn1-(func/proiz);//"следующему" х присваиваем разность "предыдущего" х и частного от функции и производной(от "предыдущего" х)
        if(((FUNC(xn2,vib,c,d)-toch)>0&&(FUNC(xn2,vib,c,d)+toch)>0)||((FUNC(xn2,vib,c,d)-toch)<0&&(FUNC(xn2,vib,c,d)+toch<0))) //проверка знаков, если разность и сумма функции от "следующего" х и точности имеет один знак, то...
  	    {
  			(*step)=((*step)+1);//через разименование указателя прибавляем переменной step единицу, чтобы она изменилась и вне функции(step отвечает за то, сколько знаков после запятой будет точность)
  			toch=pow(10.0,(-(*step)));//увеличиваем toch(отвечающую за точность) на еще один знак после запятой
  		}
		iter++;
  		printf("xn=%.10f\txn+1=%.10f\tfabs(xn-xn+1)=%.10f\ti=%d\n",xn1,xn2,fabs(xn1-xn2),iter);//для нагладности изменений выводим на экран "предыдущий" х, "следующий", их разность по модулю и количество пройденных итераций
   }while(iter<=200&&(fabs(xn1-xn2)>toch));//цикл продолжается, пока количество итераций меньше или равно 200 и разность между "предыдущим" и "следующим" х по модулю больше точности
   if(iter>=200) xn1=99999999;//если количество итераций превысило или равно 200, то х присваивается значение, показывающее "ошибку"
   return xn1;//возвращаем х
}
double SEKUSH(double, double, double , double , double, int);
//функция для вычисления приближенного значения с помощью метода секущих, принимает начальный х, переменные c, d, toch(отвечающую за точность)
//а так же указатель на переменную step(это понадобиться, чтобы в мейне вывести точность как количество знаков после запятой)
//и переменную vib, отвечающую за номер выбранного пользователем уравнения
double SEKUSH(double xn1, double xn2, double c, double d, double toch, int vib)
{
int iter=0;//переменная iter отвечает за количество итераций цикла и изначально равна нулю
double func1, func2=FUNC(xn2,vib,c,d), xs, xn=xn1, xk=xn2;//переменные func1 и func2 отвечают за значение функции на краях отрезка(так правый край отрезка никогда не меняется, его вычисляем при объявлении)
//переменная xs отвечает за следующее найденное приближение левого края отрезка, а переменные xn и xk отвечают соответственно за левый и правый край отрезка
  while(iter<=400&&(fabs(xn2-xn1)>toch))//пока количество итераций не превысит 400 и разность правого и левого края отрезка по модулю больше точности, цикл продолжается
  {
  		func1=FUNC(xn1,vib,c,d);//переменной func1 присваиваем значение функции от левого края отрезка при помощи функции FUNC
        xs=xn2-(func2*((xn2-xn1)/(func2-func1)));//ищем следующее приближение по формуле и присваиваем его xs
		iter++;
  		printf("x1=%.10f\tx2=%.10f\tfabs(x2-x1)=%.10f\ti=%d\n",xn1,xn2,fabs(xn2-xn1),iter);//для большей наглядности выводим на экран значение правого и левого края отрезка, их разность и количество пройденных итераций
  		xn1=xs;//левому краю присваиваем новое приближение
   }
   return xn1;//после выхода из цикла возвращяем левый край отрезка, так как он ближе всего к истинному корню. однако изза специфики метода, цикл поиска коря будет бесконечным
   //поэтому выводится последнее найденное значение по прохождению 400 итераций цикла
}
int main()
{
  double xn, xk, toch, c, d, step=-1, otv;//объявляем переменные xn и xk для ввода х с клавиатуры, переменную, отвечающую за точность toch, переменные c и d вводимые с клавиатуры
  //переменную step, отвечающую за количество знаков после запятой и переменную otv отвечающую за найденное значение
  int vib, vib2;//объявляем две переменные выбора, vib отвечает за выбор уравнения, а переменная vib2 за выбор способа нахождения приближенного значения
  while(vib!=0)//пока переменная выбора уравнений не равна нулю, цикл повторяется
  {
  	printf("Выберете уравнение для подсчета:\n");//на экран выводится предложение выбрать уравнение
  	printf("sin(cx)-d=0 - 1\ne^(cx)-d=0 - 2\nx^5+cx^2-d=0 - 3\nx^c-x^(c+1)+d=0 - 4\n(x^2-d)-(x^c-6)=0 - 5\n(c*xn^3-d)/(x+d)=0 - 6\nЕсли хотите завершить программу - 0\n");//на экран выводятся уравнения, которые можно решить, и вариант завершить программу. у каждого выбора свой номер
  	scanf("%d",&vib);//с клавиатуры вводится выбор пользователя
  	if(vib==0)//если пользователь выбрал завершение программы...
  	{
  	    printf("Программа завершена!\n");//вывод на экран сообщения о завершении программы
        vib=0;//переменная, отвечающая за выбор уравнений обнуляется, чтобы далее весь цикл закончился
  	}
  	else if(vib<0||vib>6) printf("Такой операции не существует, попоробуйте еще раз!\n\n");//если введена неверная операция, выводится сообщение о том, что такой операции не существует
  	else//если же номер уравнения введен правильно...
  	{
  	    while(vib2!=2&&vib2!=1)//цикл будет продолжаться, пока пользователь не введет верную операцию
  	    {
  	    printf("Выберете метод для решения\nКасательных - 1, Секущих - 2\n");//на экран выводится предложение выбрать метод для решения
            scanf("%d",&vib2);//с клавиатуры считывается выбор метода решения
            if(vib2!=2&&vib2!=1) printf("Такой операции не существует, попоробуйте еще раз!\n\n");//если введена неверная операция, выводится сообщение о том, что такой операции не существует
  	    }    
  	    switch(vib2)//конструкция switch принимает значение выбора метода решения пользователя
  	    {
	        //если пользователь выбрал метод касательных, то...
 		    case 1:
                	    printf("Введите x:\n");scanf("%lf",&xn);//ввод х
        	            printf("Введите c:\n");scanf("%lf",&c);//ввод с
  			    printf("Введите d:\n");scanf("%lf",&d);//ввод d
  			    while (step<=-1)//пока количество знаков после запятой будет меньше или равно -1...
    			    {
        		     printf("Введите точность:\n");//выводится предложение ввести точность
        		     scanf("%lf", &step);//считывается количество знаков после запятой
        		     if (step<=-1) printf("Попробуйте еще раз\n");//если количество знаков после запятой не вошло в допустимый диапазон, выводится предложение попробовать еще раз
        		     else toch=pow(10,-step);//иначе переменной toch(отвечающей за точность) присваивается приемлемый вид для вычислений в соответствии с количеством заданных знаков после запятой
    			     }
  			    otv=KASAT(xn,c,d,toch,&step,vib);//переменной otv присваиваем значение, которое вернет функция KASAT при введенных выше значениях c,d и хn, step, vib
  			    if(otv==99999999) printf("Произошла ошибка, попробуйте еще раз!\n");//если значение, которое вернет функция будет "ошибочным", то выведется сообщение об ошибке
                else printf("Корень выражения=%f найден с точностью:%f знаков после запятой\n\n",otv,step);//иначе на экран выведется найденный корень уравнения и точность
            break;//прерывание первого case
		//если пользователь выбрал пметод касательных, то...
            case 2:
 		        printf("Введите начальный х:\n");scanf("%lf",&xn);//на экран выводится предложение ввести левый край отрезка и значение считывается с клавиатуры
                	xk=xn-1;//присваиваем правому краю отрезка число, меньшее чем у левого, чтобы можно было начать проверку на вверный ввод правого края
		        while(xk<=xn)//пока правый край меньше или равен левому цикл будет проверять правильность ввода правого края отрезка
		        {
				printf("Введите конечный х:\n");scanf("%lf",&xk);//ввод правого края отрезка 
				if(xk<=xn) printf("Введен недопустимый конечный х, попробуйте еще раз\n");//если правый край оказался меньше или равен левому, то выводится сообщение об ошибке
			}
                	printf("Введите c:\n");scanf("%lf",&c);//ввод с
  		        printf("Введите d:\n");scanf("%lf",&d);//ввод d
			while (step<=-1)//пока количество знаков после запятой будет меньше или равно -1...
    			{
        		  printf("Введите точность:\n");//выводится предложение ввести точность
        		  scanf("%lf", &step);//считывается количество знаков после запятой
        		  if (step<=-1) printf("Попробуйте еще раз\n");//если количество знаков после запятой не вошло в допустимый диапазон, выводится предложение попробовать еще раз
        		  else toch=pow(10,-step);//иначе переменной toch(отвечающей за точность) присваивается приемлемый вид для вычислений в соответствии с количеством заданных знаков после запятой
    			}
  		        otv=SEKUSH(xn,xk,c,d,toch,vib);//переменной otv присваиваем значение, которое вернет функция SEKUSH при введенных выше значениях c,d и хn, xk, step, vib
                printf("Корень выражения=%f наден приближенно с точностью:%f знаков после запятой\n\n",otv,step);//вывод на экран полученного ответа
            break;//завершение второго case
  	    }
  	vib2=3;//после вычисления приближенного значения, нужно вернуть изначальные значения переменных, для корректной работы проверок    
	vib=10;//возвращаем начальное значение
	step=-1;//опять возвращаем начальное значение
  	}
	
  }

return 0;//завершение функции main
}
