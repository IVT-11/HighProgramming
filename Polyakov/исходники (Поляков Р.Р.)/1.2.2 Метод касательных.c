#include<stdio.h>//Подключаем стандартную библиотеку ввода и вывода
#include<math.h>//Подключаем математическую библиотеку
#include<stdlib.h>//Подключаем стандартную библиотеку в “С”, содержащую в себе функции, занимающиеся выделением памяти, контролем процесса выполнения программы, преобразованием типов и др.
#include<time.h>//Подключаем заголовочный файл стандартной библиотеки языка программирования C, содержащий типы и функции для работы с датой и временем.
#include<stdbool.h>//Подключаем стандартную библиотеку языка С, поддерживающую работу с типом данных _Bool.
float zad_func(float,float,float,int);//Прототип функции, отвечающей за значение функции f(x) в точке xn
float zad_proisv(float,float,float,int);//Прототип функции, отвечающей за значение производной функции f(x) в точке xn
int znaki(float,float,float,int,int);//Прототип функции на проверку знаков на концах отрезка
float poisk_kornei(float,float,float,int,int);//Прототип функции, отвечающей за поиск корня функции
int main()//Главная функция
{//начало функции
    int numberf,toch;//объявление целочисленных переменных, где "numberf" отвечает за номер выбранной функции, а "toch" за кол-во знаков после запятой
    float c,d,xn;//объявление вещественных переменных, где "c" и "d" параметры, которые нужно ввести с клавиатуры, а "xn" - мы ищем значение функции и значение производной в этой точке
    printf("Введите номер функции: 1 , 2 , 3 , 4 , 5 или 6\n");//выводит на экран сообщение "Введите номер функции: 1 , 2 , 3 , 4 , 5 или 6"
    scanf("%d",&numberf);//пользователь должен ввести значение "numberf" с клавиатуры
    printf("Введите значение параметра c: ");//выводит на экран сообщение "Введите значение параметра c: " 
    scanf("%f",&c);//пользователь должен ввести значение "c" с клавиатуры
    if(numberf==1)//условие, если пользователь ввёл первую функцию 
    {//начало условия
        while(c==0) //цикл, когда "c" равно нулю; т.к. в формуле в знаменателе "c*cos(c*xn)", то "c" не должно равняться нулю, поэтому выводится сообщение с просьбой ввести другое значение "c"  не равное нулю
        {//начало цикла
            printf("Введите ещё раз, c  не должно быть равно нулю\n");//выводит на экран сообщение "Введите ещё раз, c  не должно быть равно нулю"
            scanf("%f",&c); //пользователь должен ввести значение "c" с клавиатуры
        }//конец цикла
    } //конец условия
    if(numberf==2)//условие, если пользователь ввёл вторую функцию
    {//начало условия
        while(c>0) //цикл, когда "c" больше нуля ; т.к. по формуле xn^2+c=0, то "c" не должно быть больше нуля, т.к. если "c">0 получится ,что xn^2 будет равно отрицательному числу
        {//начало цикла
            printf("Введите еще раз , c должно быть меньше или равно нулю\n");//выводит на экран сообщение "Введите еще раз , c должно быть меньше или равно нулю"
            scanf("%f",&c); //пользователь должен ввести значение "c"
        }//конец цикла
    }//конец условия
    if(numberf==3)//условие , если пользователь ввёл третью функцию
    {//начало условия
        while(c<=0) //цикл, когда "c" меньше или равно нулю ; т.к. в формуле в знаменателе "c", то "c" не должно равняться нулю, а также т.к. аргумент логарифма не может быть отрицательным или нулевым, поэтому "c" должно быть больше нуля; поэтому выводится сообщение с просьбой ввести другое значение "c" большее нуля
        {//начало цикла
            printf("Введите еще раз , c должно быть > нуля\n");//выводит на экран сообщение "Введите еще раз , c должно быть > нуля"
            scanf("%f",&c); //пользователь должен ввести значение "c"
        }//конец цикла
    }//конец условия 
    printf("Введите значение параметра d: ");//выводит на экран сообщение "Введите значение параметра d: "
    scanf("%f",&d);//пользователь должен ввести значение "d" с клавиатуры
    printf("Введите начальное значение xn: ");//выводит на экран сообщение "Введите начальное значение xn: "
    scanf("%f",&xn);//пользователь должен ввести значение "xn" с клавиатуры
    if(numberf==2)//условие , если пользователь ввёл вторую функцию
    {//начало условия
        while(xn==0) //цикл, когда "xn" равно нулю ; т.к. в формуле в знаменателе "2*xn", то "xn" не должно равняться нулю, поэтому выводится сообщение с просьбой ввести другое значение "xn"  не равное нулю
        {//начало цикла
            printf("Введите еще раз , xn  не должно быть равно нулю\n");//выводит на экран сообщение "Введите еще раз , xn не должно быть равно нулю"
            scanf("%f",&xn); //пользователь должен ввести значение "xn" с клавиатуры
        }//конец цикла
    } //конец условия 
    if(numberf==3)//условие, если пользователь ввёл третью функцию
    {//начало условия
        while(xn<=0) //цикл, когда "xn" меньше или равно нулю ; т.к. аргумент логарифма не может быть отрицательным или нулевым, поэтому "xn" должно быть больше нуля; поэтому выводится сообщение с просьбой ввести другое значение "xn" большее нуля
        {//начало цикла
            printf("Введите еще раз , xn должно быть > нуля\n");//выводит на экран сообщение "Введите еще раз , xn должно быть > нуля"
            scanf("%f",&xn); //пользователь должен ввести значение "xn" с клавиатуры
        }//конец цикла
    }//конец условия 
    if(numberf==4)//условие , если пользователь ввёл четвёртую функцию
    {//начало условия
        while(xn==0) //цикл, когда "xn" равно нулю ; т.к.в формуле в знаменателе "3*pow(xn,2)", то "xn" не должно равняться нулю, поэтому выводится сообщение с просьбой ввести другое значение "xn"  не равное нулю
        {//начало цикла
            printf("Введите еще раз , xn не должно быть равно нулю\n");//выводит на экран сообщение "Введите еще раз , xn не должно быть равно нулю"
            scanf("%f",&xn); //пользователь должен ввести значение "xn" с клавиатуры
        }//конец цикла
    }//конец условия
    printf("Введите точность расчетов: ");//выводит на экран сообщение "Введите точность расчетов: "
    scanf("%d",&toch);//пользователь должен ввести значение "toch" с клавиатуры
    printf("Корень из f(x) : %f ",poisk_kornei(c,d,xn,toch,numberf));//выводит на экран значение корня функции
    return 0;//возвращает нуль
}//конец функции
float zad_func(float c,float d,float xn,int numberf)//функция, отвечающая за значение функции f(x) в точке xn
{//начало функции
    float fx;//объявление вещественной переменной "fx", отвечающей за функции      
    if(numberf==1) fx=sin(c*xn)-d;// если выбрана 1-я функция
    if(numberf==2) fx=pow(xn,2)+c;// если выбрана 2-я функция
    if(numberf==3) fx=log2(c*xn)-d;// если выбрана 3-я функция
    if(numberf==4) fx=pow(xn,3)-c;// если выбрана 4-я функция
    if(numberf==5) fx=pow(xn,4)+c*pow(xn,3)-d*xn;// если выбрана 5-я функция
    if(numberf==6) fx=xn+c+d;// если выбрана 6-я функция
    return fx;//возвращает значение функции в точке xn
}//конец функции
float zad_proisv(float c,float d,float xn,int numberf)//функция, отвечающая за значение производной функции f(x) в точке xn
{//начало функции
float px;//объявление вещественной переменной "px", отвечающей за производные от функций 
    if(numberf==1) px=c*cos(c*xn);// если выбрана 1-я функция
    if(numberf==2) px=2*xn;// если выбрана 2-я функция
    if(numberf==3) px=c/(c*xn*log(2));// если выбрана 3-я функция
    if(numberf==4) px=3*pow(xn,2);// если выбрана 4-я функция
    if(numberf==5) px=4*pow(xn,3)+c*3*pow(xn,2)-d;// если выбрана 5-я функция
    if(numberf==6) px=1;// если выбрана 6-я функция
    return px;// возвращает значение производной в точке xn
}//конец функции
int znaki(float c,float d,float xn1,int numberf,int toch)//функция проверки знаков функции на концах отрезка
{//начало функции
    int left, right;//объявление целочисленных переменных "left" и "right", которые отвечают за хранение значений функции на концах отрезка
    left=zad_func(c,d,xn1,numberf)-pow(10,-toch);//проверка знаков функции в левой части
    right=zad_func(c,d,xn1,numberf)+pow(10,-toch);//проверка знаков функции в правой части
    if((left>0 && right>0)||(left<0 && right<0))//условие, если знаки правой и левой части либо оба отрицательные, либо оба положительные
    return true;//если условие выполняется, то возвращаем true
    else//если ложно
    return false;//возвращаем false
}//конец функции
float poisk_kornei(float c,float d,float xn,int toch,int numberf)//функция, отвечающая за поиск корня функции
{//начало функции
int i=0;//объявление целочисленной переменной "i" и присваивание ей значения нуль; "i" отвечает за итерации
float xn1,a;//объявление вещественных переменных "xn1" и "a"; "xn1" - это точка, в которой касательная пересекает ось абсцисс; "a" - доп.переменная
a=xn-zad_func(c,d, xn, numberf)/zad_proisv(c,d,xn,numberf);//присваивание "a" значения:xn-zad_func(c,d, xn, numberf)/zad_proisv(c,d,xn,numberf);Для чего нужна доп.переменная: Если не вводить доп переменную (в нашем случае а), то:1) мы посчитаем xn1 ,2) xn присвоим xn1, т.е. получится, что xn == xn1 ,3) заходим в проверку, а там получается: xn — xn1 = 0 , 4)Условие сработало => выходим из цикла. Но это ошибка.
	while(fabs(a-xn1)>pow(10,-toch))// цикл, в котором считается точность
    {//начало цикла
        a=xn;// присваивание "a" значения "xn"
        if(i>200)//условие для проверки кол-ва итераций
        {//начало условия
	printf("Кол-во итераций превышено, ошибка (-1)\n");//выводит на экран "Кол-во итераций превышено, ошибка (-1)"
	break;//выход, если условие нарушено
        }//конец условия
	xn1=xn-zad_func(c,d, xn, numberf)/zad_proisv(c,d,xn,numberf);//формула вычисления точки отсчета
	xn=xn1;//присваивание "xn" значения "xn1"; точка отсёта "xn"  становится новой точкой отсчета(xn1)
	i++;//увеличение i на 1
    }//конец цикла
	if(znaki(c,d,xn1,numberf,toch))//условие ,проверяем, чтобы значения функции в точках слева и справа от данной (при прибавлении заданной точности) имели РАЗНЫЕ знаки, иначе нужно продолжпть вычисления, но точность на 1 знак больше
    { //начало условия
       printf("Корень из f(x) : %f ",poisk_kornei(c,d,xn,toch++,numberf));//выводит на экран искомый корень
    }//конец условия
    else//если ложно
    return xn1;//возвращает "xn1"
}//конец функции
