// заголовочные файлы стандартной библиотеки языка Си
#include <stdio.h>
#include <stdlib.h>
#include <math.h> // файл для выполнения простых математических операций
#include <time.h> // файл для работы с датой и временем

typedef double (*f)(double x, int c, int d); // указатель на функцию

// прототипы функций, дают информацию о преобразованиях типов между аргументами
double f1(double , int , int );
double f2(double , int , int );
double f3(double , int , int );
double s(f , double , double , double , int , int );

double f1(double x, int c, int d) // собственная функция для вычисления заданного уравнения
{ // начало тела функции
    return sin(c*x)-d; // оператор завершает выполнение функции и возвращает результат при ее вызове
} // конец тела функции

double f2(double x, int c, int d)
{
    return pow(x,4)+c*pow(x,3)-d*x;
}

double f3(double x, int c, int d)
{
    return pow(x,5)+c*pow(x,2)-d;
}

double s(f p, double xn, double xk, double eps, int c, int d) // собственная функция для вычисления точки приближения
{
    int i=0; // переменная целого типа, считает кол-во итераций
    double x; // переменная вещественного типа, является результатом вычислений функции
    
    do { // начало цикла с постусловием
    if(i>50) // если число итераций достигло значительного, а точность не достигается, целесообразно сделать дополнительную проверку знаков функции или прервать
    {
        if((xk-eps>=0 && xk+eps>=0) || (xk-eps<=0 && xk+eps<=0)) // дополнительная проверка знаков функции
        eps/=10; // если условие выполняется, продолжаем вычисление приближений, взяв меньшее eps
        else // если дополнительная проверка знаков функции не выполняется, прерываем цикл, вернув признак ошибки
        break; // выход из цикла
    }
    x=xk-(p(xk,c,d)*(xk-xn))/(p(xk,c,d)-p(xn,c,d)); // нахождение точки приближения уравнения
    xn=xk; // переменной хn присваивается значение xk 
    xk=x; // переменной хk присваивается следующее приближенное значение x, вычисленное в цикле
    i++; // счетчик итераций увеличивается на единицу с каждым циклом
    printf("Итерация = %2d, х = %9f\n", i,x); // вывод сообщения с № итерации и приближенным значением х
    } while(fabs(xk-xn)>eps && i<200); // условие выхода из цикла
        
    if(i>=200) // если точность достигла значительного числа итераций, возвращаем признак ошибки
    {
        printf("Ошибка\n\n"); // вывод сообщения об ошибке
        return -1; // признак ошибки
    }
    else // если точность не достигла значительного числа итераций, возвращаем результат
    {
        printf("Кол-во итераций = %d\n\n",i); // вывод кол-ва итераций
        return x; // результат вычисления функции
    }
}

int main() // функция выполнения
{
    int c,d; // переменные целого типа, константы
    double xn,xk,eps; // переменные вещественного типа
    srand(time(NULL)); // функция выполняет инициализацию генератора случайных чисел

    // определение случайных значений для переменных с и d
    c=(rand()%10)-5;
    d=(rand()%10)-5;
    
    printf("Первая приближенная точка: "); // функция ввода точки х с клавиатуры
    scanf ("%lf",&xn); // функция считывает число и выделяет под нее область памяти
    printf("вторая: ");
    scanf ("%lf",&xk);
    printf("точность вычислений: ");
    scanf ("%lf",&eps);
    
    while(1) // цикл, который будет завершен, когда условия выполнятся
    {
        // сравниваем знаменатель уравнений со значением 0
        if(f1(xk,c,d)-f1(xn,c,d)==0 || f2(xk,c,d)-f2(xn,c,d)==0 || f3(xk,c,d)-f3(xn,c,d)==0) // условие выполняется при положительном результате хотя бы одного сравнения
        {
            printf("Деление на ноль ± ∞\nПовторите ввод. Первая приближенная точка: "); // повторяем ввод при выполнении условия
            scanf ("%lf",&xn);
            printf("вторая: ");
            scanf ("%lf",&xk);
            printf("точность вычислений: ");
            scanf ("%lf",&eps);
        }
        else if(eps<0) // проверка eps на отрицательное значение
        {
            printf("eps не может быть отрицательным\nПовторите ввод. Первая приближенная точка: ");
            scanf ("%lf",&xn);
            printf("вторая: ");
            scanf ("%lf",&xk);
            printf("точность вычислений: ");
            scanf ("%lf",&eps);
        }
        else // если условия не подтвердились, выходим из цикла
        break;
    }
    
    printf("\nс = %d, d = %d\n\n",c,d); // вывод на экран сгенерированных значений c и d

    // вызовы собственной функции для вычисления точки приближения, применяя необходимые аргументы того же типа, что и параметры функции
    s(f1,xn,xk,eps,c,d);
    s(f2,xn,xk,eps,c,d);
    s(f3,xn,xk,eps,c,d);

    return 0; // признак отсутствия ошибки
}