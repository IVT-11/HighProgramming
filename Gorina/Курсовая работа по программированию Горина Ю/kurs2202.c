// заголовочные файлы стандартной библиотеки языка Си
#include <stdio.h> 
#include <stdlib.h>
#include <math.h> // файл для выполнения простых математических операций
#include <time.h> // файл для работы с датой и временем

typedef double (*f)(double x, int c, int d); // указатель на функцию

// прототипы функций, дают информацию о преобразованиях типов между аргументами
double f1(double , int , int ); 
double f2(double , int , int );
double f3(double , int , int );
double der(f , double , double , int , int );
double find(f , double , double , int , int );

double f1(double x, int c, int d) // собственная функция для вычисления заданного уравнения
{ // начало тела функции
    return sin(c*x)-d; // оператор завершает выполнение функции и возвращает результат при ее вызове
} // конец тела функции

double f2(double x, int c, int d)
{
    return pow(x,4)+c*pow(x,3)-d*x;
}

double f3(double x, int c, int d)
{
    return pow(x,5)+c*pow(x,2)-d;
}

double der(f p, double x, double eps, int c, int d) // собственная функция для вычисления производной функции
{
    return (p(x+eps,c,d)-p(x-eps,c,d))/(2*eps);
}

double find(f p , double x, double eps, int c, int d) // собственная функция для вычисления точки приближения
{
    int i=0; // переменная целого типа, считает кол-во итераций
    double xx; // переменная вещественного типа, является результатом вычислений функции
    
    do { // начало цикла с постусловием
    if(i>50) // если число итераций достигло значительного, а точность не достигается, целесообразно сделать дополнительную проверку знаков функции или прервать
    {
        if((x-eps>=0 && x+eps>=0) || (x-eps<=0 && x+eps<=0)) // дополнительная проверка знаков функции
        eps/=10; // если условие выполняется, продолжаем вычисление приближений, взяв меньшее eps
        else // если дополнительная проверка знаков функции не выполняется, прерываем цикл, вернув признак ошибки
        break; // выход из цикла
    }
    if(der(p,x,eps,c,d)==0) // условный оператор, сравниваем знаменатель уравнений со значением 0
    {
        printf("Деление на ноль ± ∞\n"); // вывод сообщения об ошибке
        break;
    }
    // если условия ложные, цикл продолжается
    xx=x-p(x,c,d)/der(p,x,eps,c,d); // приближенная точка хx пересечения касательной
    x=xx; // с каждым следующим повторением цикла значение х в уравнении приближается к заданной точности
    i++; // счетчик кол-ва итераций при достижении заданной точности
    printf("Итерация = %2d, х = %9f\n", i,xx); // вывод кол-ва итераций и соответствующего значения хx
    } while(fabs(x-xx)<eps && fabs(p(x,c,d))>eps && i<200); // после выполнения тела цикл проверяет условие
    
    if(i>=200) // если точность достигла значительного числа итераций, возвращаем признак ошибки
    {
        printf("Ошибка\n\n"); // вывод сообщения об ошибке
        return -1; // признак ошибки
    }
    else // если точность не достигла значительного числа итераций, возвращаем результат
    {
        printf("Кол-во итераций = %d\n\n",i); // вывод кол-ва итераций
        return xx; // результат вычисления функции
    }
}

int main() // функция выполнения
{
    int c,d; // переменные целого типа, константы
    double x,eps; // переменные вещественного типа
    srand(time(NULL)); // функция выполняет инициализацию генератора случайных чисел
    
    // определение случайных значений для переменных с и d
    c=(rand()%10)-5;
    d=(rand()%10)-5;
    
    printf("Произвольная точка: "); // функция ввода точки х с клавиатуры
    scanf ("%lf",&x); // функция считывает число и выделяет под нее область памяти 
    printf("точность вычислений: ");
    scanf ("%lf",&eps);
    while(1) // бесконечный цикл, выходом из которого является подтверждение условий
    {
        if(eps<0) // проверка eps на отрицательное значение
        {
            printf("eps не может быть отрицательным\nПовторите ввод. Произвольная точка: "); // повторяем ввод при несоответствии условия
            scanf ("%lf",&x);
            printf("точность вычислений: ");
            scanf ("%lf",&eps);
        }
        else // если входные данные не соответствуют условию выхода из цикла, цикл выполняется снова
        break;
    }
    
    printf("\nс = %d, d = %d\n\n",c,d); // вывод на экран сгенерированных значений c и d
    
    // вызовы собственной функции для вычисления точки приближения, применяя необходимые аргументы того же типа, что и параметры функции
    find(f1,x,eps,c,d);
    find(f2,x,eps,c,d);
    find(f3,x,eps,c,d);
    
    return 0; // признак отсутствия ошибки
}