#include<stdio.h>	//стандартная библиотека ввода-вывода данных.
#include<math.h>	//математическая библиотека в языке С.
#include<stdlib.h>	//стандартная библотека в С, содержащая в себе функции, занимающиеся выделением памяти, контролем процесса выполнения программы, преобразованием типов и другое.
#include<time.h>	//заголовочный файл стандартной библиотеки языка программирования C, содержащий типы и функции для работы с датой и временем.

int dlina, shirina;     //глобальные переменные, отвечающие за длину и ширину игрового поля.
void rules_of_game();   //функция просто выводит на экран правила игры.
void rules_of_game()
{
    printf("------------------------------\n");
    printf("Место действия этой игры — «вселенная» — это размеченная на клетки поверхность или плоскость — безграничная, ограниченная, или замкнутая (в пределе — бесконечная плоскость).\n");
    printf("Каждая клетка на этой поверхности может находиться в двух состояниях: быть «живой» (заполненной) или быть «мёртвой» (пустой).\n");
    printf("Клетка имеет восемь соседей, окружающих её.\n");
    printf("Распределение живых клеток в начале игры называется первым поколением.\n");
    printf("Каждое следующее поколение рассчитывается на основе предыдущего по таким правилам:\n"); 
    printf("В пустой (мёртвой) клетке, рядом с которой ровно три живые клетки, зарождается жизнь;\n");
    printf("если у живой клетки есть две или три живые соседки, то эта клетка продолжает жить;\n");
    printf("в противном случае, если соседей меньше двух или больше трёх, клетка умирает («от одиночества» или «от перенаселённости»).\n");
    printf("Игра прекращается, если:\n"); 
    printf("На поле не останется ни одной «живой» клетки;\n");
    printf("при очередном шаге ни одна из клеток не меняет своего состояния (складывается стабильная конфигурация).\n");
    printf("------------------------------\n");
}

void pole(int [][shirina], int [][shirina], int, int);	//прототип фун-ии, создающей первое поколение клеток.
void pole(int A[][shirina], int B[][shirina], int choose, int dlina)	//реализация этой самой фун-ии.
{ 
    int i,j;    //данные переменные служат для прохода по всему массиву. 
    printf("Первое поколение клеток!\n");	//вывод сообщения на экран.
    if(choose==1)   //сравнение,если вы выбрали единицу.
    {
        for(i=0;i<dlina;i++) 
        {	//цикл для массива. 
            for(j=0;j<shirina;j++) 
            { 
                A[i][j]=rand()%2;	//Рандомно заполняю игровое поле нулями и единицами:0 - клетка мертва, 1 - клетка жива. 
                B[i][j]=A[i][j];	/*сохраняем значения первого поколения в новый массив.
                В дальнейшем массив B[i][j] будет сохранять следующие поколения,
                а A[i][j] настоящие, чтобы их сравнивать можно было.
                (сначала 1 поколение = A[i][j],2 поколение = B[i][j], затем 3 поколение = B[i][j], а 2 поколение A[i][j]).*/
                printf("%d\t",A[i][j]); //Вывожу поле на экран. 
            } 
            printf("\n");   //перенос строки.
        }    
        printf("\n");   //перенос строки.
    }
    if(choose==2)   //сравнение,если вы выбрали двойку.
    {
        for(i=0;i<dlina;i++)
        {   //цикл для массива.
            for(j=0;j<shirina;j++)
            {
                while(1)    //пока истина.
                {
                    printf("Введите 0 или 1:\n A[%d][%d]=",i,j);    //вывод на экран значения переменных "i" и "j".
                    scanf("%d",&A[i][j]);   //вводим с клавиатуры значение элемента массива.
                    if(A[i][j]==1 || A[i][j]==0)    //если условие верно, выходим из цикла while.
                    break;  //прерывание цикла.
                }
            }
            printf("\n");   //перенос строки.
        }
        for(i=0;i<dlina;i++)
        {   //цикл для массива.
            for(j=0;j<shirina;j++)
            {
                B[i][j]=A[i][j];    /*сохраняем значения первого поколения в новый массив.
                В дальнейшем массив B[i][j] будет сохранять следующие поколения,
                а A[i][j] настоящие, чтобы их сравнивать можно было.
                (сначала 1 поколение = A[i][j],2 поколение = B[i][j], затем 3 поколение = B[i][j], а 2 поколение A[i][j]).*/
                printf("%d\t",A[i][j]); //Вывожу поле на экран.
            }
            printf("\n");   //перенос строки.
        }
        printf("\n");   //перенос строки.
    }
} 

void est_sosed(int [][shirina], int [][shirina], int);	//прототип фун-ии на проверку соседей у клетки.
void est_sosed(int A[][shirina], int B[][shirina], int dlina) //ф-ия проверяет количество соседей у клетки. 
{ 
    int i,j,zhivie=0;   //"i" и "j" служат для пробежки по массиву, "zhivie" для подсчета кол-ва живых клеток. 
    for(i=0;i<dlina;i++) 
    {   //цикл для пробега по всему массиву.
        for(j=0;j<shirina;j++) 
        { 
            if(i==0 && j==0) //условие выполняется, если попали в ВЕРХНЮЮ ЛЕВУЮ УГЛОВУЮ клетку. 
            { 
                if(A[i][j]==0) //проверка на то, что клетка мертвая.
                { 
                    zhivie=A[i][j+1]+A[i+1][j+1]+A[i+1][j]; //подсчет живых соседей угловой клетки. 
                    if(zhivie==3) B[i][j]=1; //если живых соседей 3, то клетка оживает. 
                } 
                else //если клетка оказалась живой 
                { 
                    zhivie=A[i][j+1]+A[i+1][j+1]+A[i+1][j]; //подсчет живых соседей угловой клетки. 
                    if(zhivie<2 || zhivie>3) B[i][j]=0; //если соседей меньше двух или больше трех, то клетка умирает. 
                } 
            } 
            if(i==0 && j!=0 && j!=shirina-1) //условие выполняется, если бежим по НУЛЕВОЙ СТРОКЕ(исключая угловые клетки). 
            { 
                if(A[i][j]==0) //проверка на то, что клетка мертвая. 
                { 
                    zhivie=A[i][j-1]+A[i][j+1]+A[i+1][j-1]+A[i+1][j]+A[i+1][j+1]; //подсчет живых соседей побокам и снизу(три). 
                    if(zhivie==3) B[i][j]=1; //если живых соседей 3, то клетка оживает. 
                } 
                else //если клетка оказалась живой. 
                { 
                    zhivie=A[i][j-1]+A[i][j+1]+A[i+1][j-1]+A[i+1][j]+A[i+1][j+1]; 
                    if(zhivie<2 || zhivie>3) B[i][j]=0; //если соседей меньше двух или больше трех, то клетка умирает. 
                } 
            } 
            if(i==0 && j==shirina-1) //условие выполняется, если попали в ВЕРХНЮЮ ПРАВУЮ УГЛОВУЮ клетку. 
            { 
                if(A[i][j]==0) //проверка на то, что клетка мертвая. 
                { 
                    zhivie=A[i][j-1]+A[i+1][j-1]+A[i+1][j]; //подсчет живых соседей угловой клетки. 
                    if(zhivie==3) B[i][j]=1; //если живых соседей 3, то клетка оживает. 
                } 
                else //если клетка оказалась живой. 
                { 
                    zhivie=A[i][j-1]+A[i+1][j-1]+A[i+1][j]; //подсчет живых соседей угловой клетки. 
                    if(zhivie<2 || zhivie>3) B[i][j]=0; 
                } 
            } 
            if(i==dlina-1 && j==shirina-1) //условие выполняется, если попали в НИЖНЮЮ ПРАВУЮ УГЛОВУЮ клетку. 
            { 
                if(A[i][j]==0) //проверка на то, что клетка мертвая. 
                { 
                    zhivie=A[i][j-1]+A[i-1][j]+A[i-1][j-1]; //подсчет живых соседей угловой клетки. 
                    if(zhivie==3) B[i][j]=1; //если живых соседей 3, то клетка оживает. 
                } 
                else //если клетка оказалась живой. 
                { 
                    zhivie=A[i][j-1]+A[i-1][j]+A[i-1][j-1]; //подсчет живых соседей угловой клетки. 
                    if(zhivie<2 || zhivie>3) B[i][j]=0; 
                } 
            } 
            if(i==dlina-1 && j==0) //условие выполняется, если попали в НИЖНЮЮ ЛЕВУЮ УГЛОВУЮ клетку. 
            { 
                if(A[i][j]==0) //проверка на то, что клетка мертвая. 
                { 
                    zhivie=A[i-1][j]+A[i-1][j+1]+A[i][j+1]; //подсчет живых соседей угловой клетки. 
                    if(zhivie==3) B[i][j]=1; //если живых соседей 3, то клетка оживает. 
                } 
                else //если клетка оказалась живой. 
                { 
                    zhivie=A[i-1][j]+A[i-1][j+1]+A[i][j+1]; //подсчет живых соседей угловой клетки. 
                    if(zhivie<2 || zhivie>3) B[i][j]=0; 
                } 
            } 
            if(i!=0 && j==0 && i!=dlina-1) //условие выполняется, если бежим по НУЛЕВОМУ СТОЛБЦУ(исключая угловые клетки). 
            { 
                if(A[i][j]==0) //проверка на то, что клетка мертвая. 
                { 
                    zhivie=A[i+1][j]+A[i+1][j+1]+A[i][j+1]+A[i-1][j]+A[i-1][j+1]; //подсчет живых соседей сверху один, снизу один, три справа. 
                    if(zhivie==3) B[i][j]=1; //если живых соседей 3, то клетка оживает. 
                } 
                else //если клетка оказалась живой. 
                { 
                    zhivie=A[i+1][j]+A[i+1][j+1]+A[i][j+1]+A[i-1][j]+A[i-1][j+1]; //подсчет живых соседей сверху один, снизу один, три справа. 
                    if(zhivie<2 || zhivie>3) B[i][j]=0; //если соседей меньше двух или больше трех, то клетка умирает. 
                } 
            } 
            if(i!=0 && j==shirina-1 && i!=dlina-1) //условие выполняется, если бежим по ПОСЛЕДНЕМУ СТОЛБЦУ(исключая угловые клетки). 
            { 
                if(A[i][j]==0) //проверка на то, что клетка мертвая. 
                { 
                    zhivie=A[i][j-1]+A[i+1][j]+A[i-1][j]+A[i-1][j-1]+A[i+1][j-1]; //подсчет живых соседей сверху один, снизу один, три слева. 
                    if(zhivie==3) B[i][j]=1; //если живых соседей 3, то клетка оживает. 
                } 
                else //если клетка оказалась живой. 
                { 
                    zhivie=A[i][j-1]+A[i+1][j]+A[i-1][j]+A[i-1][j-1]+A[i+1][j-1]; //подсчет живых соседей сверху один, снизу один, три слева. 
                    if(zhivie<2 || zhivie>3) B[i][j]=0; //если соседей меньше двух или больше трех, то клетка умирает 
                } 
            } 
            if(i==dlina-1 && j!=0 && j!=shirina-1) //условие выполняется, если бежим по ПОСЛЕДНЕЙ СТРОКЕ(исключая угловые клетки). 
            { 
                if(A[i][j]==0) //проверка на то, что клетка мертвая. 
                { 
                    zhivie=A[i][j-1]+A[i][j+1]+A[i-1][j]+A[i-1][j-1]+A[i-1][j+1]; //подсчет живых соседей слева один, справа один, сверху трое. 
                    if(zhivie==3) B[i][j]=1; //если живых соседей 3, то клетка оживает. 
                } 
                else //если клетка оказалась живой. 
                { 
                    zhivie=A[i][j-1]+A[i][j+1]+A[i-1][j]+A[i-1][j-1]+A[i-1][j+1]; //подсчет живых соседей слева один, справа один, сверху трое. 
                    if(zhivie<2 || zhivie>3) B[i][j]=0; //если соседей меньше двух или больше трех, то клетка умирает. 
                } 
            } 
            if(i!=0 && j!=0 && i!=dlina-1 && j!=shirina-1) //условие выполняется для ОБЩЕГО СЛУЧАЯ(исключая угловые клетки). 
            { 
                if(A[i][j]==0) //проверка на то, что клетка мертвая. 
                { 
                    zhivie=A[i][j-1]+A[i-1][j-1]+A[i-1][j]+A[i-1][j+1]+A[i][j+1]+A[i+1][j+1]+A[i+1][j]+A[i+1][j-1]; //подсчет живых соседей слева один, справа один, сверху трое, снизу трое. 
                    if(zhivie==3) B[i][j]=1; //если живых соседей 3, то клетка оживает. 
                } 
                else //если клетка оказалась живой. 
                { 
                    zhivie=A[i][j-1]+A[i-1][j-1]+A[i-1][j]+A[i-1][j+1]+A[i][j+1]+A[i+1][j+1]+A[i+1][j]+A[i+1][j-1]; //подсчет живых соседей слева один, справа один, сверху трое, снизу трое. 
                    if(zhivie<2 || zhivie>3) B[i][j]=0; //если соседей меньше двух или больше трех, то клетка умирает. 
                } 
            } 
        } 
    } 
} 

int main()	//главная функция. 
{ 
    int a=1, y=2, i, j, proverka=0, m=0, choose, choose_generation=10, choose_path;  /*переменная a - отвечает за то хотите ли вы продолжить игру или нет,
    m - отвечает за проверку поколений на совпадение, y - отвечает за номер нового поколения,
    proverka - проверяет кол-во живых соседей, choose - ваш выбор для первого поколения, choose_generation - за выбор генерации размерности
    choose_path - за то, что выбрано в гланом меню.*/
    srand(time(NULL));//привязка генерации рандомных чисел к машинному времени.
    printf("------------------------------ПРИВЕТСТВУЮ ВАС В ГЛАВНОМ МЕНЮ!------------------------------\n");//вывод сообщения на экран.
    printf("Если хотите узнать правила игры, нажмите 1\n"); //вывод сообщения на экран.
    printf("Если не хотите читать правила, нажмите 2 и игра начнется\n");   //вывод сообщения на экран.
    printf("------------------------------\n"); //вывод сообщения на экран.
    printf("Ваш выбор = "); scanf("%d",&choose_path);//вывод сообщения на экран + ввод значения переменной "choose_path".
    while(choose_path > 2 || choose_path < 1)   //проверка на "дурака". 
    {
        printf("Ваш выбор не соответствуюет данным!!! Попробуйте еще раз.\n");//вывод сообщения на экран.
        scanf("%d",&choose_path);   //ввод значения переменной "choose_path".
    }
    if(choose_path == 1) rules_of_game();//если выбрана единица, вызов фун-ии "rules_of_game".
    else    //иначе, если введена двойка.
    {
        printf("Как Вы хотите задать размерность поля?\n"); //вывод сообщения на экран.
        printf("Если хотите задать размерность сами, введите 1\n"); //вывод сообщения на экран.
        printf("Если хотите сгенерировать размерность рандомно, введите 2\n");  //вывод сообщения на экран.
        printf("Если хотите выйти, нажмите 0\n");   //вывод сообщения на экран.
        do
        {
            printf("Введите ваше действие = "); //вывод сообщения на экран.
            scanf("%d",&choose_generation); //ввод значения переменной "choose_generation"
            while(choose_generation > 2 || choose_generation < 0)   //проверка "дурака".
            {
                printf("Введена недопустимая операция, попробуйте еще раз.\n"); //вывод сообщения на экран.
                scanf("%d",&choose_generation); //повторный ввод значения переменной "choose_generation".
            }
            if(choose_generation==0) {printf("ВЫХОД!\n"); return 0;}//если выбран нуль, происходит выход и конец программы.
            else if(choose_generation==1)   //если выбрали единицу.
            {
                printf("Если хотите задать поле рандомно, нажмите 1\n");    //вывод сообщения на экран.
                printf("Если хотите заполнить поле сами, введите 2\n"); //вывод сообщения на экран.
                scanf("%d",&choose);    //ввод значения переменной "choose"
                while(choose > 2 || choose < 1) //цикл на проверку "дурака".
                {
                    printf("Введите соответствующий номер\n");    //вывод сообщения на экран.
                    scanf("%d",&choose);    //повторный ввод переменной "choose".
                }   
                if(choose==1)   //если выбрали единицу.
                {
                    printf("Длина поля=\n");	//вывод сообщения на экран. 
                    scanf("%d",&dlina);     //вводим кол-во строк поля. 
                    printf("Ширина поля=\n");	//вывод сообщения на экран. 
                    scanf("%d",&shirina);   //вводим кол-во столбцов поля.  
                    while(dlina < 3 || shirina < 3) //цикл на проверку "дурака".
                    {
                        printf("Нехватка соседей, введите минимум 3х3.\n"); //вывод сообщения на экран.
                        scanf("%d",&dlina); //повторный ввод переменной "dlina".
                        scanf("%d",&shirina);   //повторный ввод переменной "shirina".
                    }    
                }
                if(choose==2)   //если выбрали двойку.
                {
                    printf("Длина поля=\n");	//вывод сообщения на экран. 
                    scanf("%d",&dlina);     //вводим кол-во строк поля. 
                    printf("Ширина поля=\n");	//вывод сообщения на экран. 
                    scanf("%d",&shirina);   //вводим кол-во столбцов поля.  
                    while(dlina < 3 || shirina < 3) //цикл на проверку "дурака".
                    {
                        printf("Нехватка соседей, введите минимум 3х3.\n"); //вывод сообщения на экран.
                        scanf("%d",&dlina); //повторный ввод переменной "dlina".
                        scanf("%d",&shirina);   //повторный ввод переменной "shirina".
                    }
                }    
            }
            else    //если выбрана ни единица, ни нуль.
            {
                printf("Если хотите заполнить поле рандомно, введите 1\n"); //вывод сообщения на экран. 
                printf("Если хотите заполнить поле сами, введите 2\n"); //вывод сообщения на экран. 
                scanf("%d",&choose);    //ввод значения переменной "choose"
                while(choose>2 || choose<1) //цикл на проверку "дурака".
                {
                    printf("Введите соответствующий номер\n");    //вывод сообщения на экран.
                    scanf("%d",&choose);    //повторный ввод переменной "choose".
                }
                if(choose==1)   //если выбрали единицу.
                {
                    dlina=3+rand()%20;  //задаю диапазон генерации значения переменной "dlina".
                    printf("Кол-во строк = %d\n",dlina);    //вывод этого значения.
                    shirina=3+rand()%20;    //задаю диапазон генерации значения переменной "shirina".
                    printf("Кол-во столбцов = %d\n",shirina);   //вывод этого значения.
                }
                if(choose==2)   //если выбрали двойку.
                {
                    dlina=3+rand()%20;  //задаю диапазон генерации значения переменной "dlina".
                    printf("Кол-во строк = %d\n",dlina);     //вывод этого значения.
                    shirina=3+rand()%20;    //задаю диапазон генерации значения переменной "shirina".
                    printf("Кол-во столбцов = %d\n",shirina);   //вывод этого значения.    
                }    
            }
        } while(choose_generation !=1 && choose_generation !=2);//пока не введено соответствующее значение.    
        int A[dlina][shirina],B[dlina][shirina];    //объявляем два массива (массив A отвечает за текущее поколение, массив B за следующее). 
        pole(A,B,choose,dlina);	//вызов фун-ии, задающей изначальное поколение(клетки располагаются рандомно на поле).
        printf("\n");	//перенос строки. 
        while(a!=0) //как только переменная "a" примет нуль, цикл прервется и игра закончится.  
        { 
            est_sosed(A,B,dlina); //Вызов функции с генерацией следующего поколения. 
            for(i=0;i<dlina;i++)
            {	//цикл для двумерного массива (пройдемся по всему полю).
                for(j=0;j<shirina;j++)
                {
                    if(A[i][j]==B[i][j])	//условие, если значения клеток настоящего поколения равны значениям следующего поколения, то переменную 'm' увеличиваем на единицу.
                    {
                        m++;	//увеличение значения переменной на единицу. 
                    }
                    if(m==dlina*shirina)	//если число совпадений равно площади поля, игра заканчивается, т.к новые поколения не обновляются, а просто зацикливаются(это не является ошибкой программы, просто клетки так встали).
                    {
                        a=0;	//цикл прерывается и игра заканчивается.
                        printf("Игра зациклилась, конец!\n");	//вывод сообщения на экран.
                        break;	//выход из цикла.
                    }
                    else	//иначе.
                    {
                        for(i=0;i<dlina;i++) //Перезаписываем первый массив после выполнения правил. 
                        {	//цикл для двумерного массива (пройдемся по всему полю). 
                            for(j=0;j<shirina;j++) 
                            { 
                                A[i][j]=B[i][j]; /*данное действие перезапись массива делаем для того,
                                чтобы можно было в дальнейшем сравнить предыдущее поколение и нынешнее.*/
                            } 
                        } 
                        printf("%d поколение\n",y);	//номер поколения.
                        for(i=0;i<dlina;i++) 
                        {	//цикл для двумерного массива (пройдемся по всему полю). 
                            for(j=0;j<shirina;j++) 
                            { 
                                printf("%d\t",A[i][j]); //печатаем текущее поколение.
                            } 
                            printf("\n");   //перенос строки. 
                        } 
                        printf("\n");   //перенос строки.
                        proverka=0;	//присваиваем переменной "proverka" значение нуля.
                        for(i=0;i<dlina;i++) 
                        {	//цикл для двумерного массива (пройдемся по всему полю).
                            for(j=0;j<shirina;j++) 
                            { 
                                proverka+=A[i][j];	//проверяем, есть ли живые клетки на поле.
                            } 
                        } 
                        if(proverka!=0)		/*условие, если значение переменной 'proverka' не равно нулю(больше нуля, т.к клетка либо 1-жива,
                        0-мертва), поколение имеет хотя бы одну живую клетку.*/ 
                        { 
                            printf("Если хотите продолжить, введите любую цифру, если закончить, введите 0\n");	//вывод сообщения на экран. 
                            scanf("%d",&a);	//вводим повторно значение переменной "a".
                        } 
                        else a=0;   //цикл прерывается и игра заканчивается. 
                        y++;	//увеличиваем номер поколения на единицу.
                        //если условие соблюдается, вывод сообщения на экран.
                        if(y < 8 && a == 0) printf("It was very easy game, man\nВы слишком рано сдались:(\n");
                        //если условие соблюдается, вывод сообщения на экран.
                        if(y >= 8 && y < 16 && a == 0) printf("Достойный соперник!\nВы заставили попотеть эти клеточки:)\n");
                        //если условие соблюдается, вывод сообщения на экран.
                        if(y >=16 && a == 0) printf("Enough, please...\nВы получаете золотую медаль столь долгое выживание!!!\n");
                    }
                }
                if(a==0)    //если условие соблюдается.
                {
                    printf("Game over!\n");	//вывод сообщения на экран.
                    break;	//если a==0 выходим из цикла.
                }
            }
        }
    }
    return 0;	//функция возвращает нуль => выходим из функции, конец программы. 
}